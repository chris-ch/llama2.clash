-- Step 3: Modified QKV Projector that uses buffered RAM weights
--
-- This shows how to integrate the weight buffer into your qkvProjector.
-- Key changes:
-- 1. Accept weight buffer as input
-- 2. Select between hardcoded and RAM weights
-- 3. Pass RAM weights to parallelRowMatrixMultiplier

module LLaMa2.Layer.Attention.QKVProjectionWithRAM where

import Clash.Prelude
import LLaMa2.Types.ModelConfig 
    ( NumQueryHeads, ModelDimension, NumKeyValueHeads, HeadDimension, SequenceLength )
import LLaMa2.Numeric.Types ( FixedPoint )
import LLaMa2.Numeric.FixedPoint (rmsNormFwFix)
import LLaMa2.Numeric.Operations (parallelRowMatrixMultiplier)
import LLaMa2.Types.LayerData (ProcessingState (..))
import LLaMa2.Layer.Attention.FSM (processingControllerFSM)
import LLaMa2.Layer.Attention.RotaryEncoding (rotaryEncoder)
import LLaMa2.Types.Parameters (MultiHeadAttentionComponentQ (..), SingleHeadComponentQ (..))
import LLaMa2.Numeric.Quantization (RowI8E, MatI8E)

-- Import from Step 2
-- data QKVWeightBuffer = ...
-- extractQWeight, extractKWeight, extractVWeight

-- ============================================================================
-- MODIFIED: Query Head Projector with weight selection
-- ============================================================================

queryHeadProjectorWithRAM :: forall dom .
  HiddenClockResetEnable dom
  => Signal dom Bool                          -- ^ validIn
  -> Signal dom Bool                          -- ^ readyIn
  -> SingleHeadComponentQ                     -- ^ hardcoded weights (fallback)
  -> Signal dom (Index SequenceLength)
  -> Signal dom (Vec ModelDimension FixedPoint)
  -> Signal dom (MatI8E HeadDimension ModelDimension)  -- ^ RAM weights
  -> Signal dom Bool                          -- ^ useRAM (switch)
  -> ( Signal dom (Vec HeadDimension FixedPoint)
     , Signal dom Bool                        -- ^ validOut
     , Signal dom Bool                        -- ^ readyOut
     )
queryHeadProjectorWithRAM validIn readyIn headComp stepCountSig xHatSig ramWeights useRAM =
  (qRoOut, validOut, readyOut)
  where
    -- SELECT between hardcoded and RAM weights
    selectedWeights = mux useRAM ramWeights (pure (wqHeadQ headComp))
    
    -- Matrix multiply with selected weights
    (qOut, qValidOut, qReadyOut) =
      parallelRowMatrixMultiplier validIn (pure True) selectedWeights xHatSig

    -- Apply rotary encoding (combinational, but gated by valid)
    qRoOut = (rotaryEncoder (rotaryQ headComp) <$> stepCountSig) <*> qOut

    -- Pass through handshaking signals
    validOut = qValidOut
    readyOut = qReadyOut

-- ============================================================================
-- MODIFIED: Key-Value Head Projector with weight selection
-- ============================================================================

keyValueHeadProjectorWithRAM ::
  forall dom .
  HiddenClockResetEnable dom
  => Signal dom Bool                          -- ^ validIn
  -> Signal dom Bool                          -- ^ readyIn
  -> SingleHeadComponentQ                     -- ^ hardcoded weights (fallback)
  -> Signal dom (Index SequenceLength)
  -> Signal dom (Vec ModelDimension FixedPoint)
  -> Signal dom (MatI8E HeadDimension ModelDimension)  -- ^ RAM K weights
  -> Signal dom (MatI8E HeadDimension ModelDimension)  -- ^ RAM V weights
  -> Signal dom Bool                          -- ^ useRAM (switch)
  -> ( Signal dom (Vec HeadDimension FixedPoint)  -- K output
     , Signal dom (Vec HeadDimension FixedPoint)  -- V output
     , Signal dom Bool                            -- validOut
     , Signal dom Bool                            -- readyOut
     )
keyValueHeadProjectorWithRAM validIn readyIn headComp stepCountSig xHatSig ramKWeights ramVWeights useRAM =
  (kRoOut, vOut, validOut, readyOut)
  where
    -- SELECT between hardcoded and RAM weights for K
    selectedKWeights = mux useRAM ramKWeights (pure (wkHeadQ headComp))
    
    -- SELECT between hardcoded and RAM weights for V
    selectedVWeights = mux useRAM ramVWeights (pure (wvHeadQ headComp))
    
    -- K matrix multiply
    (kOut, kValidOut, kReadyOut) =
      parallelRowMatrixMultiplier validIn (pure True) selectedKWeights xHatSig

    -- V matrix multiply (runs in parallel with K)
    (vOut, vValidOut, vReadyOut) =
      parallelRowMatrixMultiplier validIn (pure True) selectedVWeights xHatSig

    -- Apply rotary to K
    kRoOut = (rotaryEncoder (rotaryQ headComp) <$> stepCountSig) <*> kOut

    -- Both K and V must be valid
    validOut = kValidOut .&&. vValidOut
    readyOut = kReadyOut .&&. vReadyOut

-- ============================================================================
-- MODIFIED: Main QKV Projector with weight buffer
-- ============================================================================

qkvProjectorWithRAM :: forall dom .
  HiddenClockResetEnable dom
  => Signal dom Bool                          -- ^ validIn
  -> Signal dom Bool                          -- ^ readyIn
  -> MultiHeadAttentionComponentQ             -- ^ hardcoded weights (fallback)
  -> Signal dom (Index SequenceLength)
  -> Signal dom (Vec ModelDimension FixedPoint)
  -> Signal dom QKVWeightBuffer               -- ^ RAM weight buffer
  -> Signal dom Bool                          -- ^ useRAM (weights fully loaded)
  -> ( Signal dom ( Vec NumQueryHeads    (Vec HeadDimension FixedPoint)
                  , Vec NumKeyValueHeads (Vec HeadDimension FixedPoint)
                  , Vec NumKeyValueHeads (Vec HeadDimension FixedPoint))
     , Signal dom Bool                        -- ^ validOut
     , Signal dom Bool                        -- ^ readyOut
     )
qkvProjectorWithRAM validIn readyIn mhaQ seqPosSig xSig weightBuffer useRAM = (qkvOut, allValid, allReady)
  where
    xNorm = rmsNormFwFix <$> xSig <*> pure (rmsAttF mhaQ)

    -- For each Q head, extract RAM weights and create projector
    qResults = imap processQHead (headsQ mhaQ)
      where
        processQHead :: Index NumQueryHeads -> SingleHeadComponentQ
                     -> (Signal dom (Vec HeadDimension FixedPoint), Signal dom Bool, Signal dom Bool)
        processQHead headIdx headQ = 
          let ramQWeights = extractQWeight <$> weightBuffer <*> pure headIdx
          in queryHeadProjectorWithRAM validIn readyIn headQ seqPosSig xNorm ramQWeights useRAM

    queryHeadsPerKV = natToNum @NumQueryHeads `div` natToNum @NumKeyValueHeads
    kvHeadIndices :: Vec NumKeyValueHeads (Index NumQueryHeads)
    kvHeadIndices = map (\i -> toEnum (fromEnum i * queryHeadsPerKV)) indicesI

    -- For each KV head, extract RAM weights and create projector
    kvResults = imap processKVHead kvHeadIndices
      where
        processKVHead :: Index NumKeyValueHeads -> Index NumQueryHeads
                      -> (Signal dom (Vec HeadDimension FixedPoint), 
                          Signal dom (Vec HeadDimension FixedPoint),
                          Signal dom Bool, Signal dom Bool)
        processKVHead kvIdx qIdx = 
          let headQ = headsQ mhaQ !! qIdx
              ramKWeights = extractKWeight <$> weightBuffer <*> pure kvIdx
              ramVWeights = extractVWeight <$> weightBuffer <*> pure kvIdx
          in keyValueHeadProjectorWithRAM validIn readyIn headQ seqPosSig xNorm 
                                         ramKWeights ramVWeights useRAM

    qVecs    = map (\(q, _, _) -> q) qResults
    qValids  = map (\(_, v, _) -> v) qResults
    qReadys  = map (\(_, _, r) -> r) qResults

    kVecs    = map (\(k, _, _, _) -> k) kvResults
    vVecs    = map (\(_, v, _, _) -> v) kvResults
    kvValids = map (\(_, _, v, _) -> v) kvResults
    kvReadys = map (\(_, _, _, r) -> r) kvResults

    allValid = (and <$> sequenceA qValids) .&&. (and <$> sequenceA kvValids)
    allReady = (and <$> sequenceA qReadys) .&&. (and <$> sequenceA kvReadys)

    qkvOut = bundle (sequenceA qVecs, sequenceA kVecs, sequenceA vVecs)

-- ============================================================================
-- MODIFIED: QKV Projection Controller (wrapper)
-- ============================================================================

qkvProjectionControllerWithRAM ::
  HiddenClockResetEnable dom =>
  Signal dom Bool                             -- ^ validIn
  -> Signal dom Bool                          -- ^ readyIn
  -> Signal dom (Vec ModelDimension FixedPoint)
  -> MultiHeadAttentionComponentQ
  -> Signal dom ProcessingState
  -> Signal dom QKVWeightBuffer               -- ^ RAM weight buffer
  -> Signal dom Bool                          -- ^ useRAM
  -> ( Signal dom ( Vec NumQueryHeads    (Vec HeadDimension FixedPoint)
                  , Vec NumKeyValueHeads (Vec HeadDimension FixedPoint)
                  , Vec NumKeyValueHeads (Vec HeadDimension FixedPoint))
     , Signal dom Bool
     , Signal dom Bool )
qkvProjectionControllerWithRAM inValid outReady input mhaQ psSig weightBuffer useRAM = 
  (result, validOut, inReady)
 where
  (enable, validOut, inReady) = processingControllerFSM inValid outReady matVecValid
  (result, matVecValid, _ready) =
    qkvProjectorWithRAM enable (pure True) mhaQ
                       (sequencePosition <$> psSig)
                       input
                       weightBuffer
                       useRAM
